# 1 - ✅         6 - ✅      11 - ✅
# 2 - ✅         7 - ✅
# 3 - ✅         8 - ✅
# 4 - ✅         9 - ✅ 
# 5 - ✅         10 - ✅


# 1. დაწერეთ ანონიმური ფუნქცია, რომელსაც გადავცემთ პარალელოგრამის
# სიმაღლეს და ფუძის ზომებს, დათვლის და დააბრუნებს ფართობს.

print((lambda h, b: h * b)(5, 10))


# 2. დაწერეთ ანონიმური ფუნქცია, რომელსაც გადავცემთ ტრაპეციის სიმაღლეს და
# პარალელური გვერდების ზომებს, დათვლის და დააბრუნებს ფართობს.

print((lambda h, a, b: ((a + b) / 2) * h)(4, 5, 6))


# 3. დაწერეთ ანონიმური ფუნქცია, რომელიც მიიღებს რიცხვს და დააბრუნებს
# გადუბლირებული სახით 15=1515, 20=2020, 17=1717

print((lambda x: int(str(x) * 2))(20))


# 4. დაწერეთ ფუნქცია, რომელსაც გადავცემთ ტექსტს და ყველა ასოს შეუცვლის
# რეგისტრს (თუ მაღალ რეგისტრშია, გადაიყვანს დაბალში და პირიქით).
# სტრინგების მეთოდებს არ იყენებთ.

def changeCase(name):
    result = ''
    for i in name:
        if 65 <= ord(i) <= 90:
            result += chr(ord(i) + 32)
        if 97 <= ord(i) <= 122:
            result += chr(ord(i) - 32)
    return result

print(changeCase('saNDro'))


# 5. დაწერეთ ფუნქცია, რომელსაც გადავცემთ ორ ასოს და ამ 
# ასოების დიაპაზონში არსებულ ყველა ასოს დააბრუნებს ერთიანი 
# სტრინგის სახით.

def letterRange(a, b):
    result = ''
    for i in range(ord(a), ord(b) + 1):
        result += chr(i)
    return result

print(letterRange('a', 'f'))


# 6. დაწერეთ ფუნქცია, რომელსაც გადავცემთ სტრინგს და დათვლის 
# რამდენი ასოა მაღალ რეგისტრში. გაითვალისწინეთ, მეთოდების, 
# რომლითაც შეგიძლიათ განსაზღვროთ სიმბოლოს რეგისტრი, გამოყენების 
# უფლება არ გაქვთ.

def countUpper(name):
    total = 0
    for i in name:
        if 65 <= ord(i) <= 90:
            total += 1
    return total

print(countUpper('sANdRo'))


# 7. დაწერეთ ფუნქცია, რომელსაც გადავცემთ სტრინგს და ყველა 
# ასოს ანბანში h-მდე გადააქცევს a-დ, დანარჩენებს b-დ.

def changeOnCond(name):
    result = ''
    for i in name:
        if 65 <= ord(i) <= 71 or 97 <= ord(i) <= 103:
            result += 'a'
        elif 72 <= ord(i) <= 90 or 104 <= ord(i) <= 122:
            result += 'b'
    return result

print(changeOnCond('aBCdefghIJklmnop'))


# 8. ფუნქცია იღებს ორ არგუმენტს, მამის და შვილის ასაკს, უნდა გამოვთვალოთ
# როდის იყო ან როდის იქნება მამა შვილზე ორჯერ დიდი.

def fatherOverSon(dad, son):
    return abs((dad - (son * 2)))

print(fatherOverSon(25, 15))


# 9. პროგრამამ გამოიმუშაოს 100 შემთხვევითი რიცხვი 65-დან 122-ის ჩათვლით და
# გამომუშავებულ რიცხვის შესაბამისი სიმბოლოებით ASCII-ის ცხრილიდან
# შექმნას ტექსტი. შემდეგ კი მიღებული ტექსტი გადასცეს ფუნქციას. ფუნქციამ
# დათვალოს და დაბეჭდოს რამდენი სიმბოლოა დაბალ რეგისტრში.

import random

def randomASCII():
    result = ''
    def countCase(x):
        count = 0
        for i in x:
            if 97 <= ord(i) <= 122:
                count += 1
        return count

    for i in range(100):
        x = random.randint(65, 123)
        result += chr(x)
    return countCase(result)

print(randomASCII())


# 10. პროგრამამ გამოიმუშაოს 100 შემთხვევითი რიცხვი 65-დან 122-ის ჩათვლით და
# გამომუშავებულ რიცხვის შესაბამისი სიმბოლოებით ASCII-ის ცხრილიდან
# შექმნას ტექსტი. შემდეგ კი მიღებული ტექსტი გადასცეს ფუნქციას. დაბეჭდოს
# რამდენჯერ მეორდება სიმბოლო “k” (სიმბოლოების დასათვლელად არ
# გამოიყენოთ ჩაშენებული ფუნქციები ან მეთოდები).

import random 
def randomASCII():
    result = ''
    def countK(x):
        count = 0
        for i in x:
            if ord(i) == 107 or ord(i) == 75:
                count += 1
        return count

    for i in range(100):
        x = random.randint(65, 123)
        result += chr(x)
    return countK(result)

print(randomASCII())


# 11. დაწერეთ ანონიმური ფუნქცია, რომელსაც გადაეცემა სამი რიცხვი და
# შეამოწმებს პირველის მეორეზე გაყოფისას მიიღება თუ არა მესამე რიცხვი.

print((lambda a, b, c: a / b == c)(10, 5, 2))
